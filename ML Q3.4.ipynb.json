{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import csv\n",
    "import os\n",
    "import math\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas\n",
    "from sklearn.model_selection import KFold\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "from sklearn.svm import SVR\n",
    "import numpy as np\n",
    "\n",
    "os.chdir('/Users/sreelakshmirajendrakumar/Downloads')\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "#finding out the number of columns of the csv file\n",
    "dataset = pandas.read_csv('OP_data2.csv')   \n",
    "X = dataset.iloc[:, 1: 19975]\n",
    "y = dataset.iloc[:, 19975] \n",
    "#converting the pandas dataframe to array \n",
    "x_data=X.to_numpy()\n",
    "y_data=y.to_numpy()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ten-fold cross validation\n",
    "kf=KFold(n_splits=10, random_state=None, shuffle=False)\n",
    "kf.get_n_splits(X)\n",
    "x_train=[]\n",
    "x_test=[]\n",
    "y_train=[]\n",
    "y_test=[]\n",
    "for train_index, test_index in kf.split(X):\n",
    "    #print(\"TRAIN:\", train_index, \"TEST:\", test_index)\n",
    "    X_train, X_test = x_data[train_index], x_data[test_index]\n",
    "    x_train.append(X_train)\n",
    "    x_test.append(X_test)\n",
    "    Y_train, Y_test = y_data[train_index], y_data[test_index] \n",
    "    y_train.append(Y_train)\n",
    "    y_test.append(Y_test)    \n",
    "\n",
    "l_data=np.arange(0,.31,.01) \n",
    "d=19974\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def multivariate(X_train,Y_train,l):           \n",
    "    #restructuring the X_test array\n",
    "    N=len(X_train)\n",
    "    W=[]\n",
    "    Z=[]\n",
    "    for i in range(0,d):\n",
    "        W.append([])\n",
    "        Z.append([])\n",
    "        index_0=[]\n",
    "        index_1=[]\n",
    "        for j in range(0,N):\n",
    "            if Y_train[j]==0:\n",
    "                W[i].append(X_train[j][i])\n",
    "                index_0.append(j)\n",
    "            else:\n",
    "                Z[i].append(X_train[j][i])\n",
    "                index_1.append(j)\n",
    "    w=np.transpose(W)\n",
    "    z=np.transpose(Z)\n",
    "\n",
    "    # finding u_(1,0) and U_(1,1)\n",
    "    u_10=[]\n",
    "    for i in range(0,d):\n",
    "        sum=0\n",
    "        for j in range(0,len(index_0)):\n",
    "            sum+=w[j][i]\n",
    "        if len(index_0)!=0:\n",
    "            sum=sum/len(index_0)\n",
    "        u_10.append(sum)\n",
    "    \n",
    "    \n",
    "    u_11=[]\n",
    "    for i in range(0,d):\n",
    "        sum=0\n",
    "        for j in range(0,len(index_1)):\n",
    "            sum+=z[j][i]\n",
    "        if len(index_1)!=0:\n",
    "            sum=sum/len(index_1)\n",
    "        u_11.append(sum)\n",
    "    \n",
    "        \n",
    "    # finding u_1 and u_2\n",
    "    u_1=[]\n",
    "    u_2=[]\n",
    "    for i in range(0,d):\n",
    "        sum=0\n",
    "        sum_2=0\n",
    "        for j in range(0,N):\n",
    "            sum+=X_train[j][i]\n",
    "            sum_2+=((X_train[j][i])**2)\n",
    "        u_1.append(sum/N)\n",
    "        u_2.append(sum_2/N)\n",
    "\n",
    "    # apply the equation --> 1. checking the value of lambda and element-wise opeation on the matrices\n",
    "\n",
    "    N_0=len(index_0)\n",
    "    N_1=len(index_1)\n",
    "\n",
    "    condition=[]\n",
    "    for i in range(0,d):\n",
    "        c=((N_0*N_1/(N**2))*(abs(u_11[i]-u_10[i])/np.sqrt(u_2[i]-(u_1[i]**2))))\n",
    "        condition.append(c)\n",
    "    \n",
    "    m_0=[]\n",
    "    m_1=[]\n",
    "    variance=[]\n",
    "    sigma=[]\n",
    "    for i in range(0,d):\n",
    "        if l>=condition[i]:\n",
    "            m_0.append(u_1[i])\n",
    "            m_1.append(u_1[i])\n",
    "            temp=(u_2[i]-(u_1[i]**2))\n",
    "            variance.append(temp)\n",
    "            sigma.append(np.sqrt(temp))\n",
    "        \n",
    "        elif l<condition[i]:\n",
    "            s=u_2[i]-(u_1[i]**2)-((N_0*N_1/N**2)*((u_11[i]-u_10[i])**2))\n",
    "            sig=abs(u_11[i]-u_10[i])*l+np.sqrt(((u_11[i]-u_10[i])**2)*(l**2)+4*s)\n",
    "            sigma.append(np.sqrt(sig))\n",
    "            if u_11[i]>=u_10[i]:\n",
    "                temp1=u_10[i]+((N_1/N)*sig*l)\n",
    "                temp2=u_11[i]-((N_0/N)*sig*l)\n",
    "                m_0.append(temp1)\n",
    "                m_1.append(temp2)\n",
    "            else:\n",
    "                temp3=u_10[i]-((N_1/N)*sig*l)\n",
    "                temp4=u_11[i]+((N_0/N)*sig*l)\n",
    "                m_0.append(temp3)\n",
    "                m_1.append(temp4)\n",
    "            \n",
    "    return m_0,m_1,sigma  \n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/ipykernel_launcher.py:61: RuntimeWarning: invalid value encountered in double_scalars\n"
     ]
    }
   ],
   "source": [
    "# find m_0,m_1,and sigma corresponding to all the training sets with different lambda values\n",
    "# this involves x_train, y_train, and lambda values    \n",
    "#for i in range(0,len(l_data)):\n",
    "M0=[]\n",
    "M1=[]\n",
    "SIGMA=[]\n",
    "n=0\n",
    "for lambd in l_data:\n",
    "    M0.append([])\n",
    "    M1.append([])\n",
    "    SIGMA.append([])\n",
    "    for j in range(0,10):\n",
    "        M0[n].append([])\n",
    "        M1[n].append([])\n",
    "        SIGMA[n].append([])\n",
    "        M0[n][j],M1[n][j],SIGMA[n][j]=multivariate(x_train[j],y_train[j],lambd)\n",
    "    n+=1\n",
    "#======================================================================   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# find the average m_0,m_1, and sigma values for diferent lambda values\n",
    "#this involves lambda values, and all the m_0, sigma, and m_1 values\n",
    "m_0_av=[]\n",
    "m_1_av=[]\n",
    "sigma_av=[]\n",
    "r=0\n",
    "for lambd in l_data:\n",
    "    m_0_av.append([])\n",
    "    m_1_av.append([])\n",
    "    sigma_av.append([])\n",
    "    for j in range(0,d):\n",
    "        a=0\n",
    "        b=0\n",
    "        c=0\n",
    "        for m in range(0,10):\n",
    "            a+=M0[m][j]\n",
    "            b+=M1[m][j]\n",
    "            c+=SIGMA[m][j]\n",
    "        a=a/10\n",
    "        b=b/10\n",
    "        c=c/10\n",
    "        m_0_av[r].append(a)\n",
    "        m_1_av[r].apend(b)\n",
    "        sigma_av[r].append(c)\n",
    "    r+=1\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# test on the test data using the equation in the question with the help of the m_0,m_1, and sigma values obtained\n",
    "# this requires the latest parameter values, x_test, y_test, and different lambda values   \n",
    "# this also requires new values of y to be computed to find the error\n",
    "Y_new=[]\n",
    "s=0\n",
    "for lambd in l_data:\n",
    "    Y_new.append([])\n",
    "    for q in range(0,len(y_data)):\n",
    "        comp1=0\n",
    "        comp2=0\n",
    "        for j in range(0,d):\n",
    "            comp1+=(((x_data[i][q][j]-m_0_av[i][j])**2)/(sigma_av[i][j]**2))\n",
    "            comp2+=(((x_data[i][q][j]-m_1_av[i][j])**2)/(sigma_av[i][j]**2))\n",
    "        if comp1<comp2:\n",
    "            Y_new[s].append(0)\n",
    "        else:\n",
    "            Y_new[s].append(1)\n",
    "    s+=1\n",
    "\n",
    "eror=[]\n",
    "w=0\n",
    "for lamd in l_data:\n",
    "    error.append([])\n",
    "    for i in range(0,len(y_data)):\n",
    "        if Y_new[w][i]!=y_data[w][i]:\n",
    "            error_rate+=1\n",
    "        error=error_rate/len(y_data)\n",
    "    w+=1\n",
    "# get the error and compare\n",
    "# this involves y_test, new y values, and lambda"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
